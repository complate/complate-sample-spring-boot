# complate-sample-spring-mvc

 This sample repository demonstrates the server-side rendering of an
[java spring](https://spring.io) application using the
[corresponding adaptor](https://github.com/complate/complate-spring-mvc).

## Getting Started

```shell script
./mvnw clean install                       # Build java application
./mvnw dependency:copy-dependencies        # Collect dependencies
npm install                                # Install js dependencies
npm run compile                            # Build JSX view
./mvnw spring-boot:run                     # Start server
```

The application should now be running on `localhost:8080`.

## Walkthrough

This sample project is based on [Spring Initializr](https://start.spring.io/).
The interesting parts is the views in `/src/main/resources/views/` and the
[SpringdemoController class](src/main/java/com/github/complate/springdemo/SpringDemoController.java),
the controller that renders the views in response to HTTP requests.

### The Spring Controller

The main component of the Spring controller is the `ComplateViewResolver` imported
from the [java spring-mvc complate adaptor](https://github.com/complate/complate-spring-mvc). To construct the
`resolver`, we need a bundled javascript file (see the views section below) and a
scripting engine.

```java
private ClassPathResource bundle = new ClassPathResource("/dist/views.js");
private NashornScriptingBridge engine = new NashornScriptingBridge();
private ComplateViewResolver resolver = new ComplateViewResolver(engine, bundle);
```

To be able to pass variables to the view to be rendered, we define a `model`.

```java
private Map<String, String> model;
```

The mapping function populates the model, dispatches on the view using a view-tag,
and renders the view.

```java
@GetMapping("/")
public void index(HttpServletRequest req, HttpServletResponse resp) throws Exception {
    model = new HashMap<>();
    model.put("age", "99");
    model.put("name", "John Doe");
    String viewTag = "Person";
    View view = resolver.resolveViewName(viewTag, Locale.US);
    if (view != null) {
        view.render(model, req, resp);
    }
}
```

This sample project specifies two mapping functions with their corresponding
views, a "person view" corresponding to `/` and a "bootstrap view"
corresponding to `/bootstrap`.

### Defining the views

In this project, `/dist/views.js` is the file containing the bundled views of
the application, and is generated by [faucet](http://faucet-pipeline.org) like
in the [getting started section](#getting-started). The [faucet example
configuration](faucet.config.js) in this project shows how to configure faucet
to generate a bundeled js file compatible with the Nashorn Scripting Engine.

`/src/main/resources/views/` contains the views of the application and
`index.js` is the entry level file that faucet uses. Its API endpoint, the
`render` function , is the only function relevant to the backend. The `render`
function
requires three arguments: `stream` which is a writable stream corresponding to
the `resp` (response) in the Spring controller, `tag` which is the name of the
view to render and `params` which is the view parameters, corresponding to the
`model` defined in the Spring controller.

```javascript
export default function render(stream, tag, params) {
    renderer.renderView(tag, params, stream, true, null);
    stream.flush();
}
```

The `render` function uses a `renderer` from the
[complate-stream](https://github.com/complate/complate-stream) library, which
is the component that actually renders the HTML. In order for this to work, the
defined views have first to be registred using the same renderer.

```javascript
import Renderer from "complate-stream";
import Person from "./person";
import BootstrapSample from "./bootstrap-sample";

let renderer = new Renderer("<!DOCTYPE html>");

[Person, BootstrapSample].forEach(view => {
	renderer.registerView(view);
});
```
